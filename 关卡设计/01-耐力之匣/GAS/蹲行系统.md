# 蹲行系统

## 设计思想：Toggle 模式

蹲行采用 **切换（Toggle）模式**：按一次进入蹲行，再按一次退出。

**核心机制**：
1. GA_Crouch 每次按键都执行完整的 Activate → End 周期
2. 通过检查 `Player.Action.Crouching` 标签判断当前状态
3. GE_Crouch 通过 Effect Container 机制应用

---

## GE_Crouch 配置

| 设置 | 值 |
|------|-----|
| 持续时间策略 | 无限 |
| 资产标签 | `Effect.Container.Crouch` |
| 修改器属性 | `BAS_Core.SpeedRate` |
| 修改器操作 | 乘法（复合） |
| 修改器值 | 0.6 |
| Target Tags (Granted) | `Player.Action.Crouching` |

**注意**：不添加 `Player.State.Danger` 标签，Danger 由 `Comp_Endurance` 的速度检测统一处理。

---

## GA_Crouch 配置

| 设置 | 值 |
|------|-----|
| 父类 | GSCGameplayAbility |
| 资产标签 | `Player.Action.Crouching` |
| 网络执行策略 | 本地预测 |
| 实例化策略 | 每个 Actor 实例化 |
| 重新触发实例化能力 | ✅ 勾选 |

### 变量

| 变量名 | 类型 | 复制 | 用途 |
|--------|------|------|------|
| Effect Container | Array (FActiveGameplayEffectHandle) | ❌ | 保存 GE 句柄用于移除 |
| ShouldEndCrouch | Boolean | ❌ | 标记是否需要在 End 时移除 GE |

### ActivateAbility 流程

```
CommitAbility
    ↓
IsCrouching (Has Tag Player.Action.Crouching)?
    ├─ True → SET ShouldEndCrouch = true → End Ability
    └─ False → Apply Effect Container (Effect.Container.Crouch)
               → SET Effect Container (保存句柄)
               → SET ShouldEndCrouch = false
               → End Ability
```

### OnEndAbility 流程

```
Branch (ShouldEndCrouch)?
    ├─ True → For Each (Effect Container)
    │            → RemoveGameplayEffectFromOwnerWithHandle
    └─ False → 不执行清理
```

### IsCrouching 宏

```
Get Ability System Component from Actor Info
    → Has Matching Gameplay Tag (Player.Action.Crouching)
    → Return True/False
```

---

## AbilitySet 配置

在 `AbilitySet_Endurance` 中：

| 设置 | 值 |
|------|-----|
| Granted Abilities | GA_Crouch |
| Input Action | IA_Core_Crouch |
| Trigger Event | Activate on Action Started |

Effect Container Map：
| 键 | 值 |
|-----|-----|
| `Effect.Container.Crouch` | GE_Crouch |

---

## 关键设计要点

### 为什么每次按键都 End Ability

如果 GA 保持激活状态，再次按键不会触发新的 ActivateAbility 事件。因此必须在每次按键处理完成后调用 End Ability，让 GA 恢复到未激活状态。

### 为什么使用句柄移除 GE

使用 `RemoveGameplayEffectFromOwnerWithHandle` 比 `RemoveBySourceEffect` 更精确：
- 保存 Apply Effect Container 返回的句柄数组
- 精确移除这次 Apply 的 GE 实例

### 变量不需要网络复制

- GA 使用本地预测，客户端和服务器各自执行
- 变量只在一次 Activate → End 周期内使用
- GE 的同步由 GAS 自动处理

---

## 实现状态

| 组件 | 状态 |
|------|------|
| GE_Crouch | ✅ 已实现 |
| GA_Crouch | ✅ 已实现 |
| Effect.Container.Crouch 标签 | ✅ 已添加 |
| AbilitySet 配置 | ✅ 已配置 |
| 动画集成 | ✅ 已实现（Blend Poses by bool） |
| 胶囊体高度变化 | ✅ 已实现 |

---

## 动画蓝图集成（ABP_Character）

### 新增变量

| 变量名 | 类型 | 用途 |
|--------|------|------|
| bIsCrouching | Boolean | 蹲行状态标记 |

### Event Graph 修改

在 `Event Blueprint Update Animation` 中添加逻辑：

```
Get Ability System Component (Character)
    ↓
Is Valid?
    ↓ True
Has Matching Gameplay Tag (Player.Action.Crouching)
    ↓
SET bIsCrouching
```

### Anim Graph 修改

在 **Locomotion** 状态机的 **Idle** 和 **Walk/Run** 状态内部：

```
Blend Poses by bool (bIsCrouching)
    ├─ True Pose → 蹲行动画/Blendspace
    │   - Idle: Anim_Crouch_Idle
    │   - Walk/Run: BS_Crouch_Idle_Walk_Run
    └─ False Pose → 站立动画/Blendspace
        - Idle: Anim_Normal_Idle
        - Walk/Run: BS_Normal_Idle_Walk_Run
```

**Blend Time**: 0.25 秒

---

## 胶囊体高度变化

### 架构

为了实现平滑过渡，逻辑分布在两个蓝图中：

| 蓝图 | 函数/事件 | 职责 |
|------|-----------|------|
| GA_Crouch | SetHalf | 获取 Character 引用，调用 HandleCrouch |
| BP_Character_Game | HandleCrouch | Timeline 平滑过渡胶囊体和 Mesh 位置 |

### BP_Character_Game.HandleCrouch

**Timeline 配置**：`StandToCrouch`
- 长度：0.25 秒
- 曲线：(0, 88) → (0.25, 65)

**流程**：
```
HandleCrouch (NeedHalf)
    ↓
Branch (NeedHalf)
    ├─ True → Play（蹲下）
    └─ False → Reverse（站起）
    ↓
Update 事件
    ├─ Set Capsule Half Height (Timeline 值)
    └─ Set Relative Location (Mesh, Z = Timeline 值 × -1)
```

### GA_Crouch.SetHalf

```
Cast To BP_Character_Game → HandleCrouch (NeedHalf)
```

### OnEndAbility 异常处理

使用 `Was Cancelled` 参数确保异常取消时也能正确恢复：

```
Was Cancelled = true? → SET ShouldEndCrouch = true（强制清理）
    ↓
Branch (ShouldEndCrouch)
    ↓ True
SetHalf(false) + RemoveWithHandle
```

